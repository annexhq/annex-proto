// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             (unknown)
// source: rpc/testservice/v1/service.proto

package testservicev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	TestService_ListTests_FullMethodName                 = "/rpc.testservice.v1.TestService/ListTests"
	TestService_ListTestRunners_FullMethodName           = "/rpc.testservice.v1.TestService/ListTestRunners"
	TestService_GetTestDefaultInput_FullMethodName       = "/rpc.testservice.v1.TestService/GetTestDefaultInput"
	TestService_ExecuteTest_FullMethodName               = "/rpc.testservice.v1.TestService/ExecuteTest"
	TestService_RetryTestExecution_FullMethodName        = "/rpc.testservice.v1.TestService/RetryTestExecution"
	TestService_GetTestExecution_FullMethodName          = "/rpc.testservice.v1.TestService/GetTestExecution"
	TestService_ListTestExecutions_FullMethodName        = "/rpc.testservice.v1.TestService/ListTestExecutions"
	TestService_ListTestCaseExecutions_FullMethodName    = "/rpc.testservice.v1.TestService/ListTestCaseExecutions"
	TestService_ListTestExecutionLogs_FullMethodName     = "/rpc.testservice.v1.TestService/ListTestExecutionLogs"
	TestService_RegisterContext_FullMethodName           = "/rpc.testservice.v1.TestService/RegisterContext"
	TestService_RegisterGroup_FullMethodName             = "/rpc.testservice.v1.TestService/RegisterGroup"
	TestService_RegisterTests_FullMethodName             = "/rpc.testservice.v1.TestService/RegisterTests"
	TestService_AckTestExecutionStarted_FullMethodName   = "/rpc.testservice.v1.TestService/AckTestExecutionStarted"
	TestService_AckTestExecutionFinished_FullMethodName  = "/rpc.testservice.v1.TestService/AckTestExecutionFinished"
	TestService_AckCaseExecutionScheduled_FullMethodName = "/rpc.testservice.v1.TestService/AckCaseExecutionScheduled"
	TestService_AckCaseExecutionStarted_FullMethodName   = "/rpc.testservice.v1.TestService/AckCaseExecutionStarted"
	TestService_AckCaseExecutionFinished_FullMethodName  = "/rpc.testservice.v1.TestService/AckCaseExecutionFinished"
	TestService_PublishTestExecutionLog_FullMethodName   = "/rpc.testservice.v1.TestService/PublishTestExecutionLog"
)

// TestServiceClient is the client API for TestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TestServiceClient interface {
	ListTests(ctx context.Context, in *ListTestsRequest, opts ...grpc.CallOption) (*ListTestsResponse, error)
	ListTestRunners(ctx context.Context, in *ListTestRunnersRequest, opts ...grpc.CallOption) (*ListTestRunnersResponse, error)
	GetTestDefaultInput(ctx context.Context, in *GetTestDefaultInputRequest, opts ...grpc.CallOption) (*GetTestDefaultInputResponse, error)
	ExecuteTest(ctx context.Context, in *ExecuteTestRequest, opts ...grpc.CallOption) (*ExecuteTestResponse, error)
	RetryTestExecution(ctx context.Context, in *RetryTestExecutionRequest, opts ...grpc.CallOption) (*RetryTestExecutionResponse, error)
	GetTestExecution(ctx context.Context, in *GetTestExecutionRequest, opts ...grpc.CallOption) (*GetTestExecutionResponse, error)
	ListTestExecutions(ctx context.Context, in *ListTestExecutionsRequest, opts ...grpc.CallOption) (*ListTestExecutionsResponse, error)
	ListTestCaseExecutions(ctx context.Context, in *ListTestCaseExecutionsRequest, opts ...grpc.CallOption) (*ListTestCaseExecutionsResponse, error)
	ListTestExecutionLogs(ctx context.Context, in *ListTestExecutionLogsRequest, opts ...grpc.CallOption) (*ListTestExecutionLogsResponse, error)
	RegisterContext(ctx context.Context, in *RegisterContextRequest, opts ...grpc.CallOption) (*RegisterContextResponse, error)
	RegisterGroup(ctx context.Context, in *RegisterGroupRequest, opts ...grpc.CallOption) (*RegisterGroupResponse, error)
	RegisterTests(ctx context.Context, in *RegisterTestsRequest, opts ...grpc.CallOption) (*RegisterTestsResponse, error)
	AckTestExecutionStarted(ctx context.Context, in *AckTestExecutionStartedRequest, opts ...grpc.CallOption) (*AckTestExecutionStartedResponse, error)
	AckTestExecutionFinished(ctx context.Context, in *AckTestExecutionFinishedRequest, opts ...grpc.CallOption) (*AckTestExecutionFinishedResponse, error)
	AckCaseExecutionScheduled(ctx context.Context, in *AckCaseExecutionScheduledRequest, opts ...grpc.CallOption) (*AckCaseExecutionScheduledResponse, error)
	AckCaseExecutionStarted(ctx context.Context, in *AckCaseExecutionStartedRequest, opts ...grpc.CallOption) (*AckCaseExecutionStartedResponse, error)
	AckCaseExecutionFinished(ctx context.Context, in *AckCaseExecutionFinishedRequest, opts ...grpc.CallOption) (*AckCaseExecutionFinishedResponse, error)
	PublishTestExecutionLog(ctx context.Context, in *PublishTestExecutionLogRequest, opts ...grpc.CallOption) (*PublishTestExecutionLogResponse, error)
}

type testServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTestServiceClient(cc grpc.ClientConnInterface) TestServiceClient {
	return &testServiceClient{cc}
}

func (c *testServiceClient) ListTests(ctx context.Context, in *ListTestsRequest, opts ...grpc.CallOption) (*ListTestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestsResponse)
	err := c.cc.Invoke(ctx, TestService_ListTests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) ListTestRunners(ctx context.Context, in *ListTestRunnersRequest, opts ...grpc.CallOption) (*ListTestRunnersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestRunnersResponse)
	err := c.cc.Invoke(ctx, TestService_ListTestRunners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) GetTestDefaultInput(ctx context.Context, in *GetTestDefaultInputRequest, opts ...grpc.CallOption) (*GetTestDefaultInputResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTestDefaultInputResponse)
	err := c.cc.Invoke(ctx, TestService_GetTestDefaultInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) ExecuteTest(ctx context.Context, in *ExecuteTestRequest, opts ...grpc.CallOption) (*ExecuteTestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteTestResponse)
	err := c.cc.Invoke(ctx, TestService_ExecuteTest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) RetryTestExecution(ctx context.Context, in *RetryTestExecutionRequest, opts ...grpc.CallOption) (*RetryTestExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetryTestExecutionResponse)
	err := c.cc.Invoke(ctx, TestService_RetryTestExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) GetTestExecution(ctx context.Context, in *GetTestExecutionRequest, opts ...grpc.CallOption) (*GetTestExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTestExecutionResponse)
	err := c.cc.Invoke(ctx, TestService_GetTestExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) ListTestExecutions(ctx context.Context, in *ListTestExecutionsRequest, opts ...grpc.CallOption) (*ListTestExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestExecutionsResponse)
	err := c.cc.Invoke(ctx, TestService_ListTestExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) ListTestCaseExecutions(ctx context.Context, in *ListTestCaseExecutionsRequest, opts ...grpc.CallOption) (*ListTestCaseExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestCaseExecutionsResponse)
	err := c.cc.Invoke(ctx, TestService_ListTestCaseExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) ListTestExecutionLogs(ctx context.Context, in *ListTestExecutionLogsRequest, opts ...grpc.CallOption) (*ListTestExecutionLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestExecutionLogsResponse)
	err := c.cc.Invoke(ctx, TestService_ListTestExecutionLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) RegisterContext(ctx context.Context, in *RegisterContextRequest, opts ...grpc.CallOption) (*RegisterContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterContextResponse)
	err := c.cc.Invoke(ctx, TestService_RegisterContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) RegisterGroup(ctx context.Context, in *RegisterGroupRequest, opts ...grpc.CallOption) (*RegisterGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterGroupResponse)
	err := c.cc.Invoke(ctx, TestService_RegisterGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) RegisterTests(ctx context.Context, in *RegisterTestsRequest, opts ...grpc.CallOption) (*RegisterTestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterTestsResponse)
	err := c.cc.Invoke(ctx, TestService_RegisterTests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) AckTestExecutionStarted(ctx context.Context, in *AckTestExecutionStartedRequest, opts ...grpc.CallOption) (*AckTestExecutionStartedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckTestExecutionStartedResponse)
	err := c.cc.Invoke(ctx, TestService_AckTestExecutionStarted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) AckTestExecutionFinished(ctx context.Context, in *AckTestExecutionFinishedRequest, opts ...grpc.CallOption) (*AckTestExecutionFinishedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckTestExecutionFinishedResponse)
	err := c.cc.Invoke(ctx, TestService_AckTestExecutionFinished_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) AckCaseExecutionScheduled(ctx context.Context, in *AckCaseExecutionScheduledRequest, opts ...grpc.CallOption) (*AckCaseExecutionScheduledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckCaseExecutionScheduledResponse)
	err := c.cc.Invoke(ctx, TestService_AckCaseExecutionScheduled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) AckCaseExecutionStarted(ctx context.Context, in *AckCaseExecutionStartedRequest, opts ...grpc.CallOption) (*AckCaseExecutionStartedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckCaseExecutionStartedResponse)
	err := c.cc.Invoke(ctx, TestService_AckCaseExecutionStarted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) AckCaseExecutionFinished(ctx context.Context, in *AckCaseExecutionFinishedRequest, opts ...grpc.CallOption) (*AckCaseExecutionFinishedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckCaseExecutionFinishedResponse)
	err := c.cc.Invoke(ctx, TestService_AckCaseExecutionFinished_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testServiceClient) PublishTestExecutionLog(ctx context.Context, in *PublishTestExecutionLogRequest, opts ...grpc.CallOption) (*PublishTestExecutionLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishTestExecutionLogResponse)
	err := c.cc.Invoke(ctx, TestService_PublishTestExecutionLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestServiceServer is the server API for TestService service.
// All implementations should embed UnimplementedTestServiceServer
// for forward compatibility
type TestServiceServer interface {
	ListTests(context.Context, *ListTestsRequest) (*ListTestsResponse, error)
	ListTestRunners(context.Context, *ListTestRunnersRequest) (*ListTestRunnersResponse, error)
	GetTestDefaultInput(context.Context, *GetTestDefaultInputRequest) (*GetTestDefaultInputResponse, error)
	ExecuteTest(context.Context, *ExecuteTestRequest) (*ExecuteTestResponse, error)
	RetryTestExecution(context.Context, *RetryTestExecutionRequest) (*RetryTestExecutionResponse, error)
	GetTestExecution(context.Context, *GetTestExecutionRequest) (*GetTestExecutionResponse, error)
	ListTestExecutions(context.Context, *ListTestExecutionsRequest) (*ListTestExecutionsResponse, error)
	ListTestCaseExecutions(context.Context, *ListTestCaseExecutionsRequest) (*ListTestCaseExecutionsResponse, error)
	ListTestExecutionLogs(context.Context, *ListTestExecutionLogsRequest) (*ListTestExecutionLogsResponse, error)
	RegisterContext(context.Context, *RegisterContextRequest) (*RegisterContextResponse, error)
	RegisterGroup(context.Context, *RegisterGroupRequest) (*RegisterGroupResponse, error)
	RegisterTests(context.Context, *RegisterTestsRequest) (*RegisterTestsResponse, error)
	AckTestExecutionStarted(context.Context, *AckTestExecutionStartedRequest) (*AckTestExecutionStartedResponse, error)
	AckTestExecutionFinished(context.Context, *AckTestExecutionFinishedRequest) (*AckTestExecutionFinishedResponse, error)
	AckCaseExecutionScheduled(context.Context, *AckCaseExecutionScheduledRequest) (*AckCaseExecutionScheduledResponse, error)
	AckCaseExecutionStarted(context.Context, *AckCaseExecutionStartedRequest) (*AckCaseExecutionStartedResponse, error)
	AckCaseExecutionFinished(context.Context, *AckCaseExecutionFinishedRequest) (*AckCaseExecutionFinishedResponse, error)
	PublishTestExecutionLog(context.Context, *PublishTestExecutionLogRequest) (*PublishTestExecutionLogResponse, error)
}

// UnimplementedTestServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTestServiceServer struct {
}

func (UnimplementedTestServiceServer) ListTests(context.Context, *ListTestsRequest) (*ListTestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTests not implemented")
}
func (UnimplementedTestServiceServer) ListTestRunners(context.Context, *ListTestRunnersRequest) (*ListTestRunnersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestRunners not implemented")
}
func (UnimplementedTestServiceServer) GetTestDefaultInput(context.Context, *GetTestDefaultInputRequest) (*GetTestDefaultInputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestDefaultInput not implemented")
}
func (UnimplementedTestServiceServer) ExecuteTest(context.Context, *ExecuteTestRequest) (*ExecuteTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTest not implemented")
}
func (UnimplementedTestServiceServer) RetryTestExecution(context.Context, *RetryTestExecutionRequest) (*RetryTestExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryTestExecution not implemented")
}
func (UnimplementedTestServiceServer) GetTestExecution(context.Context, *GetTestExecutionRequest) (*GetTestExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestExecution not implemented")
}
func (UnimplementedTestServiceServer) ListTestExecutions(context.Context, *ListTestExecutionsRequest) (*ListTestExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestExecutions not implemented")
}
func (UnimplementedTestServiceServer) ListTestCaseExecutions(context.Context, *ListTestCaseExecutionsRequest) (*ListTestCaseExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestCaseExecutions not implemented")
}
func (UnimplementedTestServiceServer) ListTestExecutionLogs(context.Context, *ListTestExecutionLogsRequest) (*ListTestExecutionLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestExecutionLogs not implemented")
}
func (UnimplementedTestServiceServer) RegisterContext(context.Context, *RegisterContextRequest) (*RegisterContextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterContext not implemented")
}
func (UnimplementedTestServiceServer) RegisterGroup(context.Context, *RegisterGroupRequest) (*RegisterGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterGroup not implemented")
}
func (UnimplementedTestServiceServer) RegisterTests(context.Context, *RegisterTestsRequest) (*RegisterTestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTests not implemented")
}
func (UnimplementedTestServiceServer) AckTestExecutionStarted(context.Context, *AckTestExecutionStartedRequest) (*AckTestExecutionStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckTestExecutionStarted not implemented")
}
func (UnimplementedTestServiceServer) AckTestExecutionFinished(context.Context, *AckTestExecutionFinishedRequest) (*AckTestExecutionFinishedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckTestExecutionFinished not implemented")
}
func (UnimplementedTestServiceServer) AckCaseExecutionScheduled(context.Context, *AckCaseExecutionScheduledRequest) (*AckCaseExecutionScheduledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckCaseExecutionScheduled not implemented")
}
func (UnimplementedTestServiceServer) AckCaseExecutionStarted(context.Context, *AckCaseExecutionStartedRequest) (*AckCaseExecutionStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckCaseExecutionStarted not implemented")
}
func (UnimplementedTestServiceServer) AckCaseExecutionFinished(context.Context, *AckCaseExecutionFinishedRequest) (*AckCaseExecutionFinishedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckCaseExecutionFinished not implemented")
}
func (UnimplementedTestServiceServer) PublishTestExecutionLog(context.Context, *PublishTestExecutionLogRequest) (*PublishTestExecutionLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishTestExecutionLog not implemented")
}

// UnsafeTestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestServiceServer will
// result in compilation errors.
type UnsafeTestServiceServer interface {
	mustEmbedUnimplementedTestServiceServer()
}

func RegisterTestServiceServer(s grpc.ServiceRegistrar, srv TestServiceServer) {
	s.RegisterService(&TestService_ServiceDesc, srv)
}

func _TestService_ListTests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ListTests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ListTests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ListTests(ctx, req.(*ListTestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_ListTestRunners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestRunnersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ListTestRunners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ListTestRunners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ListTestRunners(ctx, req.(*ListTestRunnersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_GetTestDefaultInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestDefaultInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).GetTestDefaultInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_GetTestDefaultInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).GetTestDefaultInput(ctx, req.(*GetTestDefaultInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_ExecuteTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ExecuteTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ExecuteTest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ExecuteTest(ctx, req.(*ExecuteTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_RetryTestExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryTestExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).RetryTestExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_RetryTestExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).RetryTestExecution(ctx, req.(*RetryTestExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_GetTestExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).GetTestExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_GetTestExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).GetTestExecution(ctx, req.(*GetTestExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_ListTestExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ListTestExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ListTestExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ListTestExecutions(ctx, req.(*ListTestExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_ListTestCaseExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestCaseExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ListTestCaseExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ListTestCaseExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ListTestCaseExecutions(ctx, req.(*ListTestCaseExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_ListTestExecutionLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestExecutionLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).ListTestExecutionLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_ListTestExecutionLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).ListTestExecutionLogs(ctx, req.(*ListTestExecutionLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_RegisterContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).RegisterContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_RegisterContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).RegisterContext(ctx, req.(*RegisterContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_RegisterGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).RegisterGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_RegisterGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).RegisterGroup(ctx, req.(*RegisterGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_RegisterTests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).RegisterTests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_RegisterTests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).RegisterTests(ctx, req.(*RegisterTestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_AckTestExecutionStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckTestExecutionStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).AckTestExecutionStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_AckTestExecutionStarted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).AckTestExecutionStarted(ctx, req.(*AckTestExecutionStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_AckTestExecutionFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckTestExecutionFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).AckTestExecutionFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_AckTestExecutionFinished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).AckTestExecutionFinished(ctx, req.(*AckTestExecutionFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_AckCaseExecutionScheduled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckCaseExecutionScheduledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).AckCaseExecutionScheduled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_AckCaseExecutionScheduled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).AckCaseExecutionScheduled(ctx, req.(*AckCaseExecutionScheduledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_AckCaseExecutionStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckCaseExecutionStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).AckCaseExecutionStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_AckCaseExecutionStarted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).AckCaseExecutionStarted(ctx, req.(*AckCaseExecutionStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_AckCaseExecutionFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckCaseExecutionFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).AckCaseExecutionFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_AckCaseExecutionFinished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).AckCaseExecutionFinished(ctx, req.(*AckCaseExecutionFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestService_PublishTestExecutionLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishTestExecutionLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServiceServer).PublishTestExecutionLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestService_PublishTestExecutionLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServiceServer).PublishTestExecutionLog(ctx, req.(*PublishTestExecutionLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TestService_ServiceDesc is the grpc.ServiceDesc for TestService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TestService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.testservice.v1.TestService",
	HandlerType: (*TestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTests",
			Handler:    _TestService_ListTests_Handler,
		},
		{
			MethodName: "ListTestRunners",
			Handler:    _TestService_ListTestRunners_Handler,
		},
		{
			MethodName: "GetTestDefaultInput",
			Handler:    _TestService_GetTestDefaultInput_Handler,
		},
		{
			MethodName: "ExecuteTest",
			Handler:    _TestService_ExecuteTest_Handler,
		},
		{
			MethodName: "RetryTestExecution",
			Handler:    _TestService_RetryTestExecution_Handler,
		},
		{
			MethodName: "GetTestExecution",
			Handler:    _TestService_GetTestExecution_Handler,
		},
		{
			MethodName: "ListTestExecutions",
			Handler:    _TestService_ListTestExecutions_Handler,
		},
		{
			MethodName: "ListTestCaseExecutions",
			Handler:    _TestService_ListTestCaseExecutions_Handler,
		},
		{
			MethodName: "ListTestExecutionLogs",
			Handler:    _TestService_ListTestExecutionLogs_Handler,
		},
		{
			MethodName: "RegisterContext",
			Handler:    _TestService_RegisterContext_Handler,
		},
		{
			MethodName: "RegisterGroup",
			Handler:    _TestService_RegisterGroup_Handler,
		},
		{
			MethodName: "RegisterTests",
			Handler:    _TestService_RegisterTests_Handler,
		},
		{
			MethodName: "AckTestExecutionStarted",
			Handler:    _TestService_AckTestExecutionStarted_Handler,
		},
		{
			MethodName: "AckTestExecutionFinished",
			Handler:    _TestService_AckTestExecutionFinished_Handler,
		},
		{
			MethodName: "AckCaseExecutionScheduled",
			Handler:    _TestService_AckCaseExecutionScheduled_Handler,
		},
		{
			MethodName: "AckCaseExecutionStarted",
			Handler:    _TestService_AckCaseExecutionStarted_Handler,
		},
		{
			MethodName: "AckCaseExecutionFinished",
			Handler:    _TestService_AckCaseExecutionFinished_Handler,
		},
		{
			MethodName: "PublishTestExecutionLog",
			Handler:    _TestService_PublishTestExecutionLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/testservice/v1/service.proto",
}
